function error = musclepath_poly(numdofs,muscles,mydir)

% Based on pathpoly.m by Ton van den Bogert
%
% Computes best fitting polynomial for muscle-tendon length L as a function
% of kinematic degrees of freedom q.
%
% This is done from moment arms generated by Opensim, using the relationship
% <momentarm of muscle m with respect to dof q> = -dLm/dq
%
% Stopping criteria: either error < 10% of maximum moment arm or 2mm, 
% whichever is greater, or change in error < 5% of error 
%
% input: structure "muscles", created by "opensim_get_parameters.m"
% output: error = 0 if successful, -1 if not
%
% The moment arms are read from .mat files created by "get_momentarms.m"
% named: "momarms_<muscle name>.mat", e.g. "momarms_FDSR.mat"
% 
% The polynomials are written in files: "poly_results.mat" and
% "poly_results.txt"
%
% Dimitra Blana, December 2011
%
% UPDATE June 18 2012: both lengths and moment arms are fitted (not just
% moment arms), and at least one term that includes every degree of freedom
% the muscle crosses is required.
%
% UPDATE August 2nd 2012: instead of including at least one term for each
% dof, the equations for each dof are *scaled* to the maximum moment arm/length 
% Also, the constant term of the polynomial is estimated as well.

%% open files and read in moment arms
format long;			% so we get full precision output for polynomial coefficients

% log file (output)
logfilename = [mydir '\pathpoly.log'];
logfile = fopen(logfilename,'w');
if (logfile < 0)
    errordlg(['Could not open log file ',logfilename,' for writing'],'File Error');
    fclose('all');
    error = -1;
    return;
end

% results file (output)
polyfilename = [mydir '\poly_results.txt'];
polyfile = fopen(polyfilename,'w');
if (polyfile < 0)
    errordlg(['Could not open results file ',polyfilename,' for writing'],'File Error');
    fclose('all');
    error = -1;
    return;
end

%% main loop for each muscle element
for imus = 1:length(muscles)
    
    % get moment arm out of .mat file created by get_momentarms.m
    musfilename = [mydir,'\momarms_',muscles{imus}.name,'.mat'];
    try
        ma = load(musfilename);
    catch
        errordlg(['Could not open ',musfilename,' for reading. Please make sure you run "get_momentarms.m" first.'],'File Error');
        fclose('all');
        error = -1;
        return;
    end    
    
    % get lengths out of .mat file created by get_lengths.m
    musfilename = [mydir,'\lengths_',muscles{imus}.name,'.mat'];
    try
        lg = load(musfilename);
    catch
        errordlg(['Could not open ',musfilename,' for reading. Please make sure you run "get_lengths.m" first.'],'File Error');
        fclose('all');
        error = -1;
        return;
    end  
    
    mus = muscles{1,imus};
    ndofs = length(mus.dofnums); % number of dofs spanned by this muscle
    order = 4; % polynomial order
        
    num_data = size(ma.alljnts,1);
    
    % count how many parameters the polynomial model for muscle length has
    npar = prod(1:ndofs+order)/prod(1:ndofs)/prod(1:order);
    fprintf(1,'Muscle name:      %s\n',mus.name);
    fprintf(1,'Number of DOFs:   %d\n',ndofs);
    fprintf(1,'Polynomial order: %d\n',order);
    fprintf(1,'Potential number of polynomial terms: %d\n',npar);
    tot_data = num_data*(ndofs+1);	% total number of data points
    A = zeros(tot_data, npar);      % allocate memory space for A
    b = zeros(tot_data, 1);         % allocate memory space for b

    % get angle values for the dofs the muscle crosses
    musdof_indeces = zeros(ndofs,1);
    for idof = 1:ndofs
        imusdof = mus.dofnums(idof);
        musdof_indeces(idof) = imusdof;
    end
    ang = (ma.alljnts(:,musdof_indeces) + 1e-6);	% protect against angle = 0.0
   
    maxmomdof = zeros(1,ndofs);
    for idof = 1:ndofs
        maxmomdof(idof) = max(abs(ma.allmomarms(:,idof)))*1000;
    end    
    maxall = max(maxmomdof);
    % this normalises all moment arms
    ml_weight = (maxmomdof)/maxall;
    % Stopping criterion: error less than 10% of maximum moment arm (in mm) 
    % for the muscle or 2mm, whichever is greater
    momarm_error = max(0.1*maxall,2); 

    for idof = 1:ndofs
        % read moment arm from allmomarms matrix
        % and angles from alljnts matrix
        b((idof-1)*num_data+1:idof*num_data) = -ma.allmomarms(:,idof)/ml_weight(idof);
        
        % generate the npar polynomial terms, and for each term, add a column to A
        polylist = zeros(npar,ndofs);
        expon = zeros(num_data,ndofs);	% start with all exponents zero
        for ii=1:npar
            polylist(ii,:) = expon(1,:);
            A((idof-1)*num_data+1:idof*num_data,ii) = (expon(:,idof).*prod(ang.^expon,2)./ang(:,idof))/ml_weight(idof); % contribution of this term to moment arm idof
            % generate the next set of exponents, but remain within model order
            k = 1;
            while (1)
                expon(:,k) = expon(:,k)+1;
                if (sum(expon(1,:)) > order && ii<npar)
                    expon(:,k)=0;
                    k = k+1;
                else
                    break;
                end
            end
        end     % done generating model terms
    end		% done reading all data for this muscle
    
    % <num_data> more rows for muscle length
    % read length from alllengths vector
    % and angles from alljnts matrix
    b(ndofs*num_data+1:(ndofs+1)*num_data) = lg.alllengths;

    % generate the npar polynomial terms, and for each term, add a column to A    
    for ipar=1:npar
        help = repmat(polylist(ipar,:),size(ang,1),1);
        A(ndofs*num_data+1:(ndofs+1)*num_data,ipar) = (prod(ang.^help,2));
    end  
        
    fprintf('Total number of data points: %d\n',tot_data);
   
    % now we have all data for this muscle stored in A and b
    
    % solve the full model with npar-1 terms
    p = A\b;		% compute coefficients of the best fitting model
    bpred = A*p;	% these are the moment arms predicted by this model
    res = bpred-b;	% residuals
    RMSfull = (sqrt(sum(res.^2)/tot_data)) * 1000;		% RMS of residuals, in mm
        
    fprintf('RMS fit error of the full model is: %f mm\n',RMSfull);
    fprintf('maximum moment arm: %f mm\n',maxall);
    fprintf('maximum error allowed: %f mm\n',momarm_error);
    fprintf(logfile,'%s\n',mus.name);
    fprintf(logfile,'  RMS fit error of the full model is: %f mm\n',RMSfull);
    fprintf(logfile,'  maximum moment arm: %f mm\n',maxall);
    fprintf(logfile,'  maximum error allowed: %f mm\n',momarm_error);

    % now do stepwise regression to select polynomial terms for a smaller model
    Aselected = [];
    polylist_selected = [];
    npar_selected = 0;
    % outer loop: successively add columns to Aselected
    for i = 1:npar-1
        [~, ncolumns] = size(A);
        % inner loop: find the column of A that causes most reduction in RMS when added to Aselected
        RMSnew = zeros(1,ncolumns); % this will store the RMS errors of each expanded model
        for j = 1:ncolumns
            % add column j from A to Anew
            Anew = [Aselected A(:,j)];
            % solve new p's
            pnew = Anew\b;
            % compute new RMS fit error
            RMSnew(j) = (norm(Anew*pnew - b)/(sqrt(tot_data))) * 1000; 	% convert to mm
        end
        % now determine which expanded model had the lowest RMS
        [RMSmin, col] = min(RMSnew);
        % if the change in error is less than 5%, stop without adding this term
        if ((i>1)&&((RMS - RMSmin)/RMS<0.05))
            fprintf('Change in error: %3f. No more terms added.\n ',(RMS - RMSmin)/RMS);
            fprintf(logfile,'Change in error: %3f. No more terms added.\n ',(RMS - RMSmin)/RMS);
            break;
        end
        % otherwise add this column to Aselected
        Aselected = [Aselected A(:,col)];
        npar_selected = npar_selected + 1;
        p = Aselected\b;		% solve the coefficients (again)
        % compute some error measures
        SSE = sum((Aselected*p-b).^2); 			% summed squared errors (SSE)
        RMS = (sqrt(SSE/tot_data)) * 1000; 			% RMS error, is the same as what we had before
        GCV = SSE/((num_data - npar_selected)^2);    	% Generalized Cross Validation
        AIC = log(SSE) + 2*npar_selected/tot_data;   	% Akaike's Information Criterion
        % print what we just did, on screen and on output file
        fprintf('Model addition step %3i: Added term ',i);
        fprintf('%i ',polylist(col,:));
        fprintf('-- RMS=%6.2f, GCV=%8.3e, AIC = %6.2f\n',RMS,GCV,AIC);
        fprintf(logfile,'  Model addition step %3i: Added term ',i);
        fprintf(logfile,'%i ',polylist(col,:));
        fprintf(logfile,'-- RMS=%f, GCV=%e, AIC = %f\n',RMS,GCV,AIC);

        % remember the exponents of this polynomial term
        polylist_selected = [polylist_selected ; polylist(col,:)];
        % remove this column from A and from polylist so it is not used again
        A = [A(:,1:(col-1)) A(:,(col+1):ncolumns)];
        polylist = [polylist(1:(col-1),:);polylist((col+1):ncolumns,:)];
        % stop adding terms if RMS error in fvectors is less than
        % momarm_error
        if ((RMS<=momarm_error))
            break;
        end
    end 		% and go find the next term

    % save muscle model in structure mus_model
    mus_model{imus}.name = mus.name;
    mus_model{imus}.num_lparams = npar_selected;
    mus_model{imus}.lparams = polylist_selected; % size of lparams: num_lparams x num_dofs
    mus_model{imus}.lcoef = p;
    
    % write this muscle's model in the output text file
    fprintf(polyfile,mus.name);
    fprintf(polyfile,'\nparameters %d\n',npar_selected);
    fprintf(polyfile,'# exponents ... coefficient\n');
    fprintf(polyfile,'\t');
    for i = 1:npar_selected
        fprintf(polyfile,'\t');
        fprintf(polyfile,'%3d ',polylist_selected(i,:));
        fprintf(polyfile,'   %10.5e \n', p(i));
    end
    fprintf(logfile,'  %d polynomial terms were written for %s\n',npar_selected+1, mus.name);

    % plot muscle length from Opensim and polynomial
    % if ~mod(imus,10)
    %     examine_momarms(mus_model{imus}, mus.dofnames, ma.allmomarms, ang);	
    % end
    
    clear ma;
    
end 		% go process next muscle

% save muscle models in .mat file
save([mydir '\poly_results.mat'],'mus_model');

fclose(polyfile);
fclose(logfile);
error = 0;


%=============================================================================================
function examine_momarms(musmodel, dofnames, moment_arms, angles)
% plot momentarm-angle data

% choose a subset of "angles" that contains only 100 points
a = 1;
b = size(angles,1);
r = a + (b-a).*rand(100,1);
indeces = ceil(sort(r));
sangles = angles(indeces,:);

% ...or use all angles
%indeces = 1:size(angles,1);
%sangles = angles;

% calculate moment arms from polynomial
pmoment_arms = zeros(length(indeces),length(dofnames));
for iframe = 1:length(indeces)
    for i=1:musmodel.num_lparams

        % add this term's contribution to the muscle length 
        term = musmodel.lcoef(i);

        for j=1:length(dofnames)
            for k=1:musmodel.lparams(i,j)
                term = term * sangles(iframe,j); % this creates lcoeff(i) * product of all angles to the power lparams(i,j) 
            end
        end

        % first derivatives of length with respect to all q's
        for  k=1:length(dofnames)
            % derivative with respect to q_k is zero unless exponent is 1 or higher and q is not zero
            if ((musmodel.lparams(i,k) > 0) && (sangles(iframe,k)))	
                dterm = musmodel.lparams(i,k)*term/sangles(iframe,k);
                pmoment_arms(iframe,k) = pmoment_arms(iframe,k) + dterm;
            end
        end
    end
end

figure;
for idof=1:length(dofnames)
    subplot(length(dofnames),1,idof);
    plot(moment_arms(indeces,idof),'bx'); hold on; plot(-pmoment_arms(:,idof),'ro'); 	
    title([dofnames{idof}, ' momentarms for ',musmodel.name],'Interpreter', 'none'); 
end
legend('osim','poly');
